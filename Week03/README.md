# 学习笔记

## js中的正则
### RegExp
```javascript
    let regexp = /[0-9]*/
    // 或者
    let regexp = new RegExp('[0-9]*')
```
方法   
--**exec**   
入参：字符串；   
出参：数组，其中存放匹配的结果；如果未匹配到，则返回null；  
 
例子🌰：
```javascript
let regexp = /([0-9\.]+)|([ \t]+)|([\r\n]+)|(\+)|(\-)|(\*)|(\/)/g
let str = '1024 + 10 * 25'
regexp.exec(str)
```

说明：   

    exec如果找到了匹配的文本，则返回一个结果数组；否则，返回null。 

    结果数组的第0个元素是与正则表达式相匹配的文本；第1个元素是与RegExpObject的第1个子表达式相匹配的文本（如果有的话），第2个元素是与RegExpObject的第2个子表达式相匹配的文本（如果有的话），以此类推。

    除了数组元素和length属性之外，数组还有两个属性：index属性声明的是匹配文本的第一个字符的位置；input属性则存放的是被检索的字符串string。   

    当RegExpObject是一个非全局正则表达式时，exec方法返回的数组与调用String.match方法返回的数组是相同的。
    当是一个全局正则表达式时，它会在RegExpObject的**lastIndex属性指定的字符处开始检索字符串string**。当exec找到了与表达式相匹配的文本时，在匹配后，它会将RegExpObject的**lastIndex属性设置为匹配文本的最后一个字符的下一个位置**。这就是说，可以通过反复调用exec方法来遍历字符串中的所有匹配文本。当exec再也找不到匹配的文本时，它将返回null，并把lastIndex属性重置为0。

注意：   

    如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把lastIndex属性重置为0。



--**test**   
入参：字符串   
出参：true / false 

用于测试字符串参数中是否存在匹配正则表达式模式的字符串。   
  
例子🌰
```javascript
RegExp.prototype.test(str)
```

说明：
    
    当RegExpObject是一个非全局正则表达式时，test方法始终从字符串的开头开始匹配；

    当RegExpObject是一个全局正则表达式时，test方法会从lastIndex的值的位置开始匹配；


### 字符串
方法   
--**search**   
入参：正则 / 字符串，字符串会隐式地转成正则   
出参：第一个匹配结果的index，否则返回-1

* 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串
* 方法返回第一个匹配结果index，查找不到则返回-1
* 方法**不执行全局匹配**，它将忽略标志g，并且总是从字符串的开始进行检索

例子🌰
```javascript
String.prototype.search(reg)
```

--**match**   
入参：正则 / 字符串   
出参：数组，其中存放匹配的结果；如果未匹配到，则返回null；

* 可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。

```javascript
String.prototype.match(reg)
```

说明：

    当正则表达式是一个非全局正则时，该方法返回的值与RegExp对象的exec方法返回值相同，返回一个数组，其中存放了与它找到的匹配文本有关的信息。

    该数组的第0个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。数组还包含有两个对象属性：index属性和input属性。index属性申明的是匹配文本的起始字符在字符串中的位置，input属性申明的是对字符串的引用。

    当正则表达式时一个全局正则时，该方法将执行全局检索，找到字符串中所有匹配子字符串。返回的数组中存放的是字符串中所有的匹配子串，没有index属性或input属性。
    

--**split**      
入参：字符串 / 正则表达式，howmany（指定返回的数组的最大长度， 可选）      
出参：字符串数组

* 用于把一个字符串分割成字符串数组。

说明：

    通常，返回值数组中的字串是不包含separator自身的。

    不区分是否是全局正则表达式。

    如果separator是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的字串，但不包括与整个正则表达式匹配的文本。

    如果把空字符串（''）用作separator，那么字符串中的每个字符之间都会被分割。


--**replace**   
入参：匹配规则（字符串 / 正则）， replacement（字符串 / 函数）。   
出参：一个新的字符串，是用replacement替换了regexp的第一次匹配或者所有匹配之后得到的。   

* 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

说明： 

    如果正则表达式是全局正则，那么replace方法将替换所有匹配的字串。否则，它只替换第一个匹配字串。

    replacement可以是字符串，也可以是函数。如果是字符串，那么每个匹配都将由字符串替换。replacement中的$字符具有特定的含义。
|                      |                                         |
| -------------------- | --------------------------------------- |
| $1、$2、…、$99        | 与regexp中的第1到第99个子表达式相匹配的文本   |
| $&                   | 与regexp相匹配的子串                       |
| $`                   | 位于匹配子串左侧的文本                      |
| $'                   | 位于匹配子串右侧的文本                      |
| $$                   | 直接量符号                                |


    如果replacement是函数，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数是匹配模式的字符串。接下来的参数是与模式中的子表达式匹配的字符串，可以有0个或多个这样的参数。接下来的参数是一个整数，声明了匹配在字符串中出现的位置。最后一个参数是字符串本身。
   

  

## LL算法